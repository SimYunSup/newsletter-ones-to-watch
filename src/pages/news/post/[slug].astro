---
import { getEntry, render } from "astro:content";
import * as cheerio from "cheerio";
import "@/styles/content.css";
import Layout from "@/components/BasicLayout.astro";

export const prerender = false;
export interface Props {
  slug: string;
}

const { slug } = Astro.params;
if (!slug) {
  return Astro.redirect("/404");
}
if (slug.length === 32) {
  const uuid = `${slug.slice(0, 8)}-${slug.slice(8, 12)}-${slug.slice(12, 16)}-${slug.slice(16, 20)}-${slug.slice(20)}`;
  const news = await getEntry("news", uuid);
  if (!news) {
    return Astro.redirect("/404");
  }
  return Astro.redirect(`/news/post/${uuid}`);
}
const news = await getEntry("news", String(slug));
if (!news) {
  return Astro.redirect("/404");
}

interface Match {
  url: string;
  index: number;
}
interface URLSearchResult {
  url: string;
  value: string;
  description?: string;
}

const { env } = Astro.locals.runtime;
if (news.data.cover?.type === "file") {
  await env.CRALWER_QUEUE.send({
    type: "image",
    url: news.data.cover.file.url,
    slug,
  });
}
let matches: Match[] = [];
let messages: any[] = [];
const rendered = cheerio.load(news.rendered!.html);
rendered("a.bookmark-link").each(function (index, element) {
  const elementInstance = rendered(element);
  matches.push({
    url: String(elementInstance.attr("href")),
    index,
  });
});

await Promise.all(
  matches.map(async (match) => {
    try {
      const result = await env.NEWSLETTER_CRAWL.get<URLSearchResult>(
        `url:${match.url}`,
        { type: "json" }
      );
      if (!result) {
        throw new Error("Result not found");
      }
      rendered(`a.bookmark-link[href='${result.url}']`).replaceWith(
        `<a class="bookmark-link" href="${result.url}" target="_blank" rel="noreferrer">${result.value.replace(/</g, "&lt;").replace(/>/g, "&gt;")} üîó</a>`
      );
    } catch (e) {
      console.error(e);
      messages.push({
        body: {
          type: "url",
          url: match.url,
          slug,
          attempt: 0,
          maxRetries: 3,
        },
        contentType: "json",
        delaySeconds: 2,
      });
    }
  })
);
if (messages.length > 0) {
  if (import.meta.env.DEV) {
    console.log("messages", messages);
  }
  await env.CRALWER_QUEUE.sendBatch(messages);
}
news.rendered!.html = rendered.html();
const { Content } = await render(news);
let thumbnail =
  news.data.cover?.type === "file"
    ? process.env.NODE_ENV === "production"
      ? `${env.CDN_URL}/cdn-cgi/image/width=1200/thumbnail/${slug}`
      : news.data.cover.file.url
    : undefined;
if (import.meta.env.DEV) {
  const image = await env.IMAGES.get(`thumbnail/${slug}`);

  if (image) {
    const arrayBuffer = await image.arrayBuffer();
    const base64 = Buffer.from(arrayBuffer).toString("base64");
    const contentType = image.httpMetadata?.contentType || "image/jpeg";
    thumbnail = `data:${contentType};base64,${base64}`;
  }
}
---

<Layout
  pageTitle={news.data.properties.Ïù¥Î¶Ñ}
  description={`${news.data.properties.Ïù¥Î¶Ñ} - ${new Intl.DateTimeFormat("ko-KR").format(new Date())}`}
  imageUrl={thumbnail}
>
  <!-- Reading progress bar -->
  <div class="reading-progress-bar" id="reading-progress"></div>

  <article class="container">
    {
      news.data.cover?.type === "file" && (
        <div class="image-container">
          <img src={thumbnail} alt="" />
        </div>
      )
    }
    <h1 class="title">
      {news.data.properties.Ïù¥Î¶Ñ}
    </h1>
    <div class="description">
      <p>
        {
          new Intl.DateTimeFormat("ko-KR").format(
            news.data.properties.ÎÇ†Ïßú?.start
          )
        }
      </p>
    </div>

    <!-- Table of Contents -->
    <div class="toc-container" id="table-of-contents" style="display: none;">
      <h3 class="toc-title">Î™©Ï∞®</h3>
      <ul class="toc-list" id="toc-list"></ul>
    </div>

    <div class="markdown-body" id="article-content">
      <Content />
    </div>
    <script>
      // Reading progress bar
      function updateReadingProgress() {
        const progressBar = document.getElementById('reading-progress');
        const article = document.getElementById('article-content');

        if (!progressBar || !article) return;

        const articleTop = article.offsetTop;
        const articleHeight = article.offsetHeight;
        const windowHeight = window.innerHeight;
        const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

        const scrollStart = articleTop;
        const scrollEnd = articleTop + articleHeight - windowHeight;
        const scrollProgress = (scrollTop - scrollStart) / (scrollEnd - scrollStart);

        const percentage = Math.min(Math.max(scrollProgress * 100, 0), 100);
        progressBar.style.width = `${percentage}%`;
      }

      window.addEventListener('scroll', updateReadingProgress);
      window.addEventListener('resize', updateReadingProgress);
      updateReadingProgress();

      // Table of Contents generation
      function generateTableOfContents() {
        const markdownElement = document.querySelector(".markdown-body");
        const tocContainer = document.getElementById('table-of-contents');
        const tocList = document.getElementById('toc-list');

        if (!markdownElement || !tocContainer || !tocList) return;

        const headings = markdownElement.querySelectorAll("h2");

        if (headings.length === 0) return;

        tocContainer.style.display = 'block';

        headings.forEach((heading) => {
          const id = heading.id;
          const text = heading.textContent;

          if (!id) return;

          const li = document.createElement('li');
          li.className = 'toc-item';

          const a = document.createElement('a');
          a.href = `#${id}`;
          a.textContent = text;
          a.className = 'toc-link';

          a.addEventListener('click', (e) => {
            e.preventDefault();
            heading.scrollIntoView({ behavior: 'smooth', block: 'start' });
            window.history.pushState(null, '', `#${id}`);
          });

          li.appendChild(a);
          tocList.appendChild(li);
        });

        // Highlight active section in TOC
        function updateActiveTocLink() {
          const headings = Array.from(markdownElement.querySelectorAll("h2"));
          const tocLinks = document.querySelectorAll('.toc-link');

          let activeIndex = -1;
          const scrollPosition = window.scrollY + 100;

          headings.forEach((heading, index) => {
            if (heading.offsetTop <= scrollPosition) {
              activeIndex = index;
            }
          });

          tocLinks.forEach((link, index) => {
            if (index === activeIndex) {
              link.classList.add('active');
            } else {
              link.classList.remove('active');
            }
          });
        }

        window.addEventListener('scroll', updateActiveTocLink);
        updateActiveTocLink();
      }

      generateTableOfContents();

      // Code block copy buttons
      function addCopyButtonsToCodeBlocks() {
        const markdownElement = document.querySelector(".markdown-body");
        if (!markdownElement) return;

        const codeBlocks = markdownElement.querySelectorAll('pre');

        codeBlocks.forEach((pre) => {
          const code = pre.querySelector('code');
          if (!code) return;

          const button = document.createElement('button');
          button.className = 'copy-code-button';
          button.textContent = 'Î≥µÏÇ¨';
          button.setAttribute('aria-label', 'Copy code to clipboard');

          button.addEventListener('click', async () => {
            try {
              await navigator.clipboard.writeText(code.textContent || '');
              button.textContent = 'Î≥µÏÇ¨Îê®!';
              button.classList.add('copied');

              setTimeout(() => {
                button.textContent = 'Î≥µÏÇ¨';
                button.classList.remove('copied');
              }, 2000);
            } catch (err) {
              console.error('Failed to copy code:', err);
              button.textContent = 'Ïã§Ìå®';
              setTimeout(() => {
                button.textContent = 'Î≥µÏÇ¨';
              }, 2000);
            }
          });

          pre.style.position = 'relative';
          pre.appendChild(button);
        });
      }

      addCopyButtonsToCodeBlocks();

      // Existing heading click-to-copy functionality
      const markdownElement = document.querySelector(".markdown-body");
      const headingElements = markdownElement?.querySelectorAll("h2");
      if (headingElements) {
        Array.from(headingElements).forEach((element) => {
          element.addEventListener("click", (e) => {
            const targetElement = e.currentTarget;
            if (!(targetElement instanceof Element)) {
              return;
            }
            const id = targetElement?.id;
            if (!id) {
              return;
            }
            const url = new URL(window.document.location.href);
            url.hash = `#${id}`;
            window.document.location.assign(url);
            window.navigator.clipboard.writeText(url.toString());
          });
        });
      }
    </script>
    <script
      src="https://giscus.app/client.js"
      data-repo="SimYunSup/newsletter-ones-to-watch"
      data-repo-id="R_kgDOKO1eRg"
      data-category-id="DIC_kwDOKO1eRs4CZDYo"
      data-mapping="pathname"
      data-strict="0"
      data-reactions-enabled="1"
      data-emit-metadata="0"
      data-input-position="bottom"
      data-theme="preferred_color_scheme"
      data-lang="ko"
      data-loading="lazy"
      crossorigin="anonymous"
      async></script>
  </article>
</Layout>
